(()=>{"use strict";function e(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function t(t,r){return function(e){if(Array.isArray(e))return e}(t)||function(e,t){var r=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=r){var n,o,l=[],a=!0,u=!1;try{for(r=r.call(e);!(a=(n=r.next()).done)&&(l.push(n.value),!t||l.length!==t);a=!0);}catch(e){u=!0,o=e}finally{try{a||null==r.return||r.return()}finally{if(u)throw o}}return l}}(t,r)||function(t,r){if(t){if("string"==typeof t)return e(t,r);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?e(t,r):void 0}}(t,r)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}const r=e=>{const r={};for(let o=0;o<e.length;o++){const l=e[o];for(let e=0;e<l.length;e++){const o=l[e],a=t(n(o),2),u=a[0],c=a[1];if(!(u<0))if(u===c)r[u]=[...r[u]||[],o];else for(let e=u;e<c;e++)r[e]=[...r[e]||[],o]}}return r},n=e=>[Math.min(e.start,e.end),Math.max(e.start,e.end)];var o;null==(o=self).performance&&(o.performance={}),null==o.performance.now&&(o.performance.now=()=>Date.now()),importScripts("/static/pcrelib.js");const l=Module.cwrap("pcre16_compile","number",["number","number","number","number","number"]),a=Module.cwrap("pcre16_exec","number",["number","number","number","number","number","number","number","number"]),u=Module.cwrap("pcre16_fullinfo","number",["number","number","number","number"]),c=Module.cwrap("getCalloutAddress","number",[]),s=Module.cwrap("getExtraAddress","number",[]);let i,d,f,m,b=!1,p={},g=null;function M(e){if(b){const t=e>>2,r=Module.HEAP32[t+5],n=Module.HEAP32[t+6],o=Module.HEAP32[t+10],l=Module.HEAP32[t+11];m[f]||(m[f]=[]),m[f][d]={patternStart:o,patternEnd:l,stringStart:r,stringEnd:n-r}}i++,d++}function h(e){b&&(m[f]||(m[f]=[]),m[f].steps=d,m[f].status=e,d=0,f++)}function A(e){try{const{regex:t,flags:n,testString:o,options:M}=e.data;b=!!M.isDebugging;const A=function(e,t,r){if((r.calculateSteps||r.isDebugging)&&(t+="C"),p){if(p.pattern===e&&p.flags===t)return;S()}let n=0,o=!1;for(let e=0,r=t.length;e<r;e++)switch(t[e]){case"g":o=!0;break;case"i":n|=1;break;case"m":n|=2;break;case"s":n|=4;break;case"x":n|=8;break;case"A":n|=16;break;case"C":n|=16384;break;case"D":case"E":n|=32;break;case"J":n|=524288;break;case"N":n|=4096;break;case"S":break;case"U":n|=512;break;case"X":n|=64;break;case"Y":n|=67108864;break;case"u":n|=536872960;break;case"P":n|=2048;break;default:throw new Error(`Unknown option '${t[e]}' supplied.`)}p.pattern=e,p.flags=t,p.optionBits=2097152|n,p.globalMatch=o;const a=2*(2*e.length+1),i=Module._malloc(a);Module.stringToUTF16(e,i,a);const d=Module._malloc(4),f=Module._malloc(4),m=l(i,n,d,f,null);if(!m){const e=`${function(e,t){if(0===t||!e)return"";for(var r,n=0,o=0;n|=r=HEAPU8[e+o>>0],(0!=r||t)&&(o++,!t||o!=t););t||(t=o);var l="";if(n<128){for(var a,u=1024;t>0;)a=String.fromCharCode.apply(String,HEAPU8.subarray(e,e+Math.min(t,u))),l=l?l+a:a,e+=u,t-=u;return l}return Module.UTF16ToString(e)}(Module.HEAP32[d>>2])} - offset: ${Module.HEAP32[f>>2]}`;return Module._free(i),Module._free(d),Module._free(f),S(),e||"Unknown compilation error"}(r.calculateSteps||r.isDebugging)&&(Module.HEAP32[c()>>2]=g);const b=Module._malloc(4);u(m,null,8,b),p.namedSubpatternCount=Module.HEAP32[b>>2],Module._free(b);var M=Module._malloc(4);u(m,null,9,M),p.namedSubpatternTable=M;const h=Module._malloc(4);u(m,null,7,h),p.namedSubpatternSize=Module.HEAP32[h>>2],Module._free(h);var A=Module._malloc(4);u(m,null,2,A),p.ovectorLen=3*(Module.HEAP32[A>>2]+1),Module._free(A),p.matchLimit=s(),p.regex=m,Module._free(i),Module._free(d),Module._free(f)}(t,n,M);if(A)return void self.postMessage({error:A});const E=performance.now(),P=function(e,t){if(!p.regex)throw new Error("No pattern supplied to matching function!");if(i=0,d=0,f=0,m=[],p.subject!==e||!p.testStringPointer){p.testStringPointer&&Module._free(p.testStringPointer);const t=e.length,r=2*(2*t+1),n=Module._malloc(r);Module.stringToUTF16(e,n,r),p.testStringPointer=n,p.subject=e,p.subjectLength=t}const n=Module._malloc(4*p.ovectorLen),o=n>>2;let l=0,u=0;const c=[];let s,b=0,g=null;do{if(s=a(p.regex,p.matchLimit,p.testStringPointer,p.subjectLength,l,u,n,p.ovectorLen),s>=0){h(s),d=0,0===s&&(s=p.ovectorLen/3);const t=new Array(s);let r=0;for(let n=0;n<2*s;n+=2){const l=Module.HEAP32[o+n],a=Module.HEAP32[o+n+1],u=n/2,c=-1!==l;if(t[r++]={isParticipating:c,groupNum:u,start:l,end:a,content:e.substring(l,a),match:b},c&&a>=l&&p.namedSubpatternCount>0){let e=Module.HEAP32[p.namedSubpatternTable>>2];for(let r=0;r<p.namedSubpatternCount;r++){const r=Module.HEAP8[e];void 0!==t[r]&&(t[r].groupName=Module.UTF16ToString(e+2)),e+=2*p.namedSubpatternSize}}}c[b++]=t}else{if(-1!==s){l>=p.subjectLength||(h(s),g=s);break}if(!(0!==u&&l<p.subjectLength)){d>0&&h(s);break}Module.HEAP32[o]=l,Module.HEAP32[o+1]=l+1,l<p.subjectLength-1&&"\r"===e.charAt(l)&&"\n"===e.charAt(l+1)&&(Module.HEAP32[o+1]+=1),h(s)}const r=Module.HEAP32[o+1]===Module.HEAP32[o];t.bumpalong?l=Module.HEAP32[o+1]+(r?1:0):(u=r?268435472:0,l=Module.HEAP32[o+1])}while(p.globalMatch);return Module._free(n),{matchMap:r(c),matchResult:c,error:g,calloutData:m,steps:t.calculateSteps?i:null}}(o,M);P.time=performance.now()-E,self.postMessage(P)}catch(e){console.error("An unhandled error was thrown, please report this",e),self.postMessage({error:e.message||"Unknown error occurred"})}}function S(){p.namedSubpatternTable&&Module._free(p.namedSubpatternTable),p.regex&&Module._free(p.regex),p={}}Module.onRuntimeInitialized=function(){g=Module.addFunction(M,["i","i"]),self.onmessage=A,self.postMessage("onload")}})();